# == BBTAG Intro Module v 1.0.3a == #
#
#	by dionednd
#
#	Commissioned by SkeleJ64
#

# == Changelog == #
#
#	v 0.0.1
#	- Implemented basic intro delay
#
#	v 0.0.2
#	- Added Camera parameters
#	- Fixed camera visual issues with characters that have off screen intros.
#
#	v 0.0.3
#	- Added roll orders 1 and 2
#
#	v 0.0.4
#	- Added roll orders 3 and 4
#
#	v 0.0.5
#	- Added special intro support
#
#	v 0.0.6
#	- Added music mute and winner/loser zoom from foobs' extended intro winpose module (go check out foobs' extended intro winpose module)
#
#	v 0.0.7
#	- Added off-screen intro support
#
#	v 0.0.8
#	- Fixed bug where the characters would be frozen at intro state
#
#	v 0.0.9
#	- Added Intro Movement
#
#	v 1.0.0 (Public Release)
#	- Fixed AI bugs from previous version
#	- Implemented simple AI from foobs' extended intro winpose module (go check out foobs' extended intro winpose module)
#
#	v 1.0.1
#	- Fixed an issue where players could damage each other during intro movement if a character has a movement option that can damage the enemy (like Merkava's Air Dash)
#	- Reduced the intro movement time to 3 seconds
#	- Fixed issue where the selected palette wasn't showing (idk why i didn't notice that this was being caused by my module and not a nightly bug)
#
#	v 1.0.2
#	- Added more compatibility for tag team mode. (non-team leader players will get out of the screen as soon as both teams' intros are played.)
#	- Disabled intro movement time for training mode. (isn't really needed there)
#	- Adjusted the camera during introstate = 3 to only apply whenever intro movement is over
#
#	v 1.0.3
#	- Added Stage Intros
#	- Added Stage Intro Scroll Order 1
#	- Added Delay before players do their intro
#	- Added Music Ducking during player intros (player(1), map(bbtag_introMusicFirstRound) = 2) (will add interpolation later)
#
#	v 1.0.3a
#	- Made stage intro camera smoother by adding camera lag. (will look rough if player(1), map(bbtag_IntroDelay) = 0?)
#	- Changed Duck Volume to 75%.
#	- Added Stage Name Text Support (only displays a placeholder text. will be fully implemented once strings are supported in IKEMEN GO.) (you can still use the implementation for your full games. that's the reason why i decided to add it)
#	- Started Outro Delay implimentation (no functionality yet)
#
#	Plans for v 1.0.4
#	- Outro Delay

#	but before v 1.0.3 i'll be taking a short break cuz i need to study for finals exam.

# == How To Install == #
#
#	1. Open your config.ini
#	2. look for States in [Common]
#	3. add ", data/intro_delay_specialintros.zss, data/intro_delay.zss" to your states.
#	4. make sure that intro_delay_specialintros.zss comes first before intro_delay.zss
#

# == Additional Notes == #
#
#	This module was tested with foobs' extended intro winpose module and isn't compatible with foobs' module.
#	This module wasn't made to compliment foobs' extended intro winpose module, so expect bugs when you're using both.
#	some features were imported into this module due to demand.

# == Normal States == #

[StateDef 1900000; type: S; ctrl: 0; velset: 0, 0;]


if selfAnimExist(190) {
	changeAnim{value: 190}
}
else if selfAnimExist(191) {
	changeAnim{value: 191}
}

if memberNo = player(1), map(bbtag_teamIntroState) && teamSide = player(1), map(bbtag_introState) && player(1), map(bbtag_specialIntroActive) < 1 && (time >= player(1), map(bbtag_pauseLength) || player(1), map(bbtag_pauseLength) = 0)
&& (player(1), map(bbtag_stageIntroFinished) || !player(1), map(bbtag_stageIntro))
{
	changeState{value: cond(Const(PreIntroState),Const(PreIntroState),190)}
}

# == Global States == #

[StateDef -4]
if playerno < 9 {
	if (player(1), map(bbtag_introMovement) || player(1), map(bbtag_introSkipDisabled) || player(1), map(bbtag_stageIntro)) && !isHelper && roundstate < 2
	{
		assertspecial{flag:roundnotskip;}
	}

ignorehitpause if roundState = [-1, 1] && !isHelper && teamSide != 0 && roundNo = 1
{
	# Settings
	if roundstate <= 0
	{
		# Roll Order
		# 1 = p1 - right to left / p2 - left to right
		# 2 = p1 - left to right / p2 - right to left
		# 3 = left to right for both teams (like in BBTAG)
		# 4 = right to left for both teams
		player(1), map(bbtag_rollOrder) := 3;

		# Pause (can be 0)
		player(1), map(bbtag_pauseLength) := 60;

		# Camera Lag
		player(1), map(bbtag_cameraLag) := 0.9;

		# Camera Zoom
		player(1), map(bbtag_cameraZoom) := 1.2;

		# Disable Intro Music for 1st Round 1  = Mute Music, 0 = Enable Music, 2 = Duck Music Volume during character intros
		player(1), map(bbtag_introMusicFirstRound) := 2;

		# Duck Volume
		player(1), map(bbtag_introMusicDuckVolume) := 75;

		# Intro Movement 1 = On 0 = Off
		player(1), map(bbtag_introMovement) := 1;

		# Disable Taunting during Intro Movement (ignored if Intro Movement is off.) this option was added to prevent from players gaining advantage by taunting during intro, where the enemy can't attack them. however, if your characters somehow have no meter gain during taunts, you can enable this just for fun.
		player(1), map(bbtag_introMovementTauntDisabled) := 1;

		# Disable Switching Characters (Tag Team Mode Only) during Intro Movement (ignored if Intro Movement is off.)
		player(1), map(bbtag_introMovementTagDisabled) := 1;
		
		# Time for the players to move during intro. ignored if intro movement is disabled and Pause Length is taken instead.
		player(1), map(bbtag_introMovementTime) := 180;

		# Disable Intro Skip. always on whenever Intro Movement is on.
		player(1), map(bbtag_introSkipDisabled) := 1;

		# Enable Stage Intro.
		player(1), map(bbtag_stageIntro) := 1;

		# Stage Intro Scroll Order (Ignored if stage intro is disabled)
		# 1 = Zoom out from the center of the stage then start char intros
		player(1), map(bbtag_stageIntroScrollOrder) := 1;

		# Stage Intro Duration
		player(1), map(bbtag_stageIntroTime) := 240; #120 frames = 2 seconds

		# Stage Intro Zoom
		player(1), map(bbtag_stageIntroZoom) := 2.0;

		# Delay before any of the intros begin (ignored if stage intro is disabled)
		player(1), map(bbtag_IntroDelay) := 60; #60 frames = 1 second

		# Stage Text (Ignored if stage intro is disabled)
		player(1), map(bbtag_stageText) := 0; #disabled for now. it doesn't display the stage's name due to engine limitations. once we get support for strings, i'll update this feature

		# Stage Text Params
		player(1), map(bbtag_stageTextFont) := -1;
		player(1), map(bbtag_stageTextAlign) := 0;
		player(1), map(bbtag_stageTextScaleX) := 1;
		player(1), map(bbtag_stageTextScaleY) := 1;
		player(1), map(bbtag_stageTextLayerno) := 0;
		player(1), map(bbtag_stageTextPosX) := 160;
		player(1), map(bbtag_stageTextPosY) := 120;
		player(1), map(bbtag_stageTextColorR) := 256;
		player(1), map(bbtag_stageTextColorG) := 256;
		player(1), map(bbtag_stageTextColorB) := 256;

		# Outro Delay
		player(1), map(bbtag_outroDelay) := 1; # if enabled, outroFocus is ignored.

		# Outro Delay Roll Order	
		# 1 = Winners First (from p1), Losers Last (from p2)
		# 2 = Losers First (from p2), Winners Last (from p1)
		player(1), map(bbtag_outroRollOrder) := 1; # if enabled, outroFocus is ignored.
		
		# outro delay has no functionality yet.

		# Cam Focus on Character During Outro 0 = Off 1 = Winner 2 = Loser
		player(1), map(bbtag_outroFocus) := 1;

		# Cam Zoom during Outro >1 = Zoom in <1 = Zoom out
		player(1), map(bbtag_outroZoom) := 1.2;


		# sets the palette of the player
		RemapPal{source:1,1;dest:1,palno}
	}
	AssertSpecial{flag: NoBarDisplay}
	# Stage Intro
	if player(1), map(bbtag_stageIntro) && playerno = 1
	{
		if !player(1), map(bbtag_stageIntroFinished){AssertSpecial{flag: Intro}}
		if !player(1), map(stageIntroTime) && !player(1), map(bbtag_stageIntroFinished) && !player(1), map(stageIntroBegun)
		{
			player(1), map(stageIntroBegun) := 1;
			player(1), map(stageIntroTime) := player(1), map(bbtag_stageIntroTime);
		}

		if player(1), map(stageIntroTime) >= 0
		{
			let c = (256 -  (256*(player(1), map(stageIntroTime)/player(1), map(bbtag_stageIntroTime))));
			AllPalFX{mul: $c, $c, $c;time: 2}
			if player(1), map(bbtag_stageIntroScrollOrder) = 1
			{	# (1.0 + (player(1), map(bbtag_stageIntroZoom)*(player(1), map(stageIntroTime)/player(1), map(bbtag_stageIntroTime)))) # 1.0 is the stage default zoom
				let siz = gamewidth/const240p(320/(1.0 + (player(1), map(bbtag_stageIntroZoom)*(player(1), map(stageIntroTime)/player(1), map(bbtag_stageIntroTime)))));
				zoom{scale:$siz;pos:(0/$siz)*camerazoom, 0;lag:cond(player(1), map(stageIntroTime) = player(1), map(bbtag_stageIntroTime), 0, player(1), map(bbtag_cameraLag));stagebound:1; camerabound:0}
			}
		}
		if player(1), map(stageIntroTime) > (player(1), map(bbtag_IntroDelay) * -1)
		{
			# Stage Text
			if player(1), map(bbtag_stageText) && playerno = 1
			{
				if !NumText(135790)
				{
					text{text: "Stage Text Test";localcoord:320,240;layerno:player(1), map(bbtag_stageTextLayerno);font:player(1), map(bbtag_stageTextFont);align:player(1), map(bbtag_stageTextAlign);pos:player(1), map(bbtag_stageTextPosX), player(1), map(bbtag_stageTextPosY);scale:player(1), map(bbtag_stageTextScaleX),player(1), map(bbtag_stageTextScaleY);id:135790;textdelay:4;removetime:player(1), map(bbtag_stageIntroTime)+player(1), map(bbtag_IntroDelay);color:player(1), map(bbtag_stageTextColorR),player(1), map(bbtag_stageTextColorG),player(1), map(bbtag_stageTextColorB),0;}
				}
				else if NumText(135790) && player(1), map(stageIntroTime) > (player(1), map(bbtag_IntroDelay) * -1)
				{
					ModifyText{id:135790;color:player(1), map(bbtag_stageTextColorR),player(1), map(bbtag_stageTextColorG),player(1), map(bbtag_stageTextColorB), cond(player(1), map(stageIntroTime) <= 0, 256-(256*((player(1), map(stageIntroTime)*-1)/player(1), map(bbtag_IntroDelay))),(256 -  (256*(player(1), map(stageIntroTime)/player(1), map(bbtag_stageIntroTime)))));}
				}
			}

			if player(1), map(stageIntroTime) < 0
			{
				let fz = gamewidth/const240p(320/1);
				zoom{scale:$fz;lag:player(1), map(bbtag_cameraLag); pos:(0/$siz)*camerazoom, 0; stagebound:1; camerabound:0}
			}
			player(1), map(stageIntroTime) := player(1), map(stageIntroTime) - 1;
		}

		if player(1), map(stageIntroTime) = (player(1), map(bbtag_IntroDelay) * -1) && !player(1), map(bbtag_stageIntroFinished)
		{
			player(1), map(bbtag_stageIntroFinished) := 1;
		}

	}

	# DO NOT TOUCH THE NEXT LINES UNLESS YOU DON'T KNOW WHAT YOU'RE DOING.
	if map(bbtag_specialIntro) != 1 {call specialIntroCheck();}

	if !player(1), map(bbtag_introState) && !player(1), map(bbtag_teamIntroState)
	{
		player(1), map(bbtag_introState) := cond(player(1), map(bbtag_rollOrder) = 4,2, 1);
		player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_rollOrder) = 1,1, cond(teamMode = turns,1,NumPartner + 1));
	}
	if player(1), map(bbtag_introState) > 0 && player(1), map(bbtag_introState) < 3 && map(bbtag_specialIntro) != 1 && player(1), map(bbtag_specialIntroActive) < 1
	{

		AssertSpecial{flag: Intro}
		if teamSide = player(1), map(bbtag_introState) && (player(1), map(bbtag_stageIntroFinished) || !player(1), map(bbtag_stageIntro))
		{
			# Music Volume Ducking
			if player(1), map(bbtag_introMusicFirstRound) = 2
			{
				ModifyBGM{volume:player(1), map(bbtag_introMusicDuckVolume)}
			}
			if memberNo = player(1), map(bbtag_teamIntroState)
			{
				# let them continue their animation and focus the camera on them
				let z = gamewidth/const240p(320/player(1), map(bbtag_cameraZoom));
				zoom{scale:$z;lag:player(1), map(bbtag_cameraLag); pos:(pos x/$z)*camerazoom, 0; stagebound:1; camerabound:0;}

				if stateno = 0 && (time >= player(1), map(bbtag_pauseLength) || player(1), map(bbtag_pauseLength) = 0)
				{
					map(bbtag_playerIntroFinished) := 1;
					if player(1), map(bbtag_rollOrder) = 1 {player(1), map(bbtag_teamIntroState) := player(1), map(bbtag_teamIntroState) + 1;}
					else if player(1), map(bbtag_rollOrder) = 2 {player(1), map(bbtag_teamIntroState) := player(1), map(bbtag_teamIntroState) - 1;}
					else if player(1), map(bbtag_rollOrder) = 3 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 1, player(1), map(bbtag_teamIntroState) - 1, player(1), map(bbtag_teamIntroState) + 1);}
					else if player(1), map(bbtag_rollOrder) = 4 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 2, player(1), map(bbtag_teamIntroState) - 1, player(1), map(bbtag_teamIntroState) + 1);}

					if (player(1), map(bbtag_teamIntroState) > cond(teamMode = turns,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 1)
					|| (player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 2)
					|| ((player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 3 && player(1), map(bbtag_introState) = 1) || (player(1), map(bbtag_teamIntroState) > cond(teamMode = turns,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 3 && player(1), map(bbtag_introState) = 2))
					|| ((player(1), map(bbtag_teamIntroState) > cond(teamMode = turns,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 4 && player(1), map(bbtag_introState) = 1) || (player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 4 && player(1), map(bbtag_introState) = 2))
					{
						player(1), map(bbtag_introState) := cond(player(1), map(bbtag_rollOrder) = 4, cond(player(1), map(bbtag_introState) = 2,1,3),player(1), map(bbtag_introState) + 1);
						if player(1), map(bbtag_rollOrder) = 1 {player(1), map(bbtag_teamIntroState) := 1;}
						else if player(1), map(bbtag_rollOrder) = 2 {player(1), map(bbtag_teamIntroState) := cond(teamMode = turns,1,NumPartner + 1);}
						else if player(1), map(bbtag_rollOrder) = 3 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 1, cond(teamMode = turns,1,NumPartner + 1), 1);}
						else if player(1), map(bbtag_rollOrder) = 4 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 2, cond(teamMode = turns,1,NumPartner + 1), 1);}
					}
				}
			}
			else
			{
				if map(bbtag_playerIntroFinished) != 1
				{
					ChangeState{value:1900000; continue:0}
				}
			}
		}
		else
		{
			if map(bbtag_playerIntroFinished) != 1
			{
				ChangeState{value:1900000; continue:0}
			}
		}
	}

	if player(1), map(bbtag_introState) = 3
	{
		# Music Volume Ducking
		if player(1), map(bbtag_introMusicFirstRound) = 2
		{
			ModifyBGM{volume:100}
		}

		if player(1), map(introMovementTime) = 0 && player(1), map(introMovementTimeFinished) = 0 && player(1), map(bbtag_introMovement)
		{
			player(1), map(introMovementTime) := player(1), map(bbtag_introMovementTime);
		}
		if !ctrl && stateno = 0 && (time >= player(1), map(bbtag_pauseLength) || player(1), map(bbtag_pauseLength) = 0) && player(1), map(bbtag_introMovement) && TeamLeader = playerno {ctrlSet{value: 1}}
		if TeamLeader != playerno && teamMode = Tag
		{
			# if teamMode is tag and char is not the teamleader, take away control and take them out the screen
			if ctrl {ctrlSet{value: 0}}
			if stateno = 0 {tagOut{stateno: const(StateTagLeavingScreen)}}
		}
		if player(1), map(bbtag_specialIntroActive) < 1 && player(1), map(introMovementTimeFinished) = 0 && roundstate < 2 && (player(1), map(bbtag_stageIntroFinished) || !player(1), map(bbtag_stageIntro))
		{
			let z = gamewidth/const240p(320/1);
			zoom{scale:$z;lag:player(1), map(bbtag_cameraLag); pos:(((player(1), pos x + player(2), pos x)/$z)*camerazoom) / 2, 0; stagebound:1; camerabound:0;}
		}
		if player(1), map(introMovementTime) > 0 && player(1), map(bbtag_introMovement)
		{
			AssertSpecial{flag: Intro}
			
			if playerno = 1 {player(1), map(introMovementTime) := player(1), map(introMovementTime) - 1;}
			if playerno = 1 && gamemode = "training" {player(1), map(introMovementTime) := 0;}
			if player(1), map(introMovementTime) = 0 && player(1), map(introMovementTimeFinished) = 0 {player(1), map(introMovementTimeFinished) := 1;}
		}
	}

	if player(1), map(bbtag_specialIntroActive) > 0 && stateno != 19000000 && map(bbtag_specialIntro) != 1
	{
		ChangeState{value:1900000; continue:0}
	}

}

if roundstate = [-1, 1] && map(bbtag_specialIntro) = 1 && memberNo = player(1), map(bbtag_teamIntroState) && teamSide = player(1), map(bbtag_introState) && !isHelper && player(1), map(bbtag_specialIntroActive) = 0
{
	map(bbtag_playerIntroFinished) := 1;
	if player(1), map(bbtag_rollOrder) = 1 {player(1), map(bbtag_teamIntroState) := player(1), map(bbtag_teamIntroState) + 1;}
	else if player(1), map(bbtag_rollOrder) = 2 {player(1), map(bbtag_teamIntroState) := player(1), map(bbtag_teamIntroState) - 1;}
	else if player(1), map(bbtag_rollOrder) = 3 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 1, player(1), map(bbtag_teamIntroState) - 1, player(1), map(bbtag_teamIntroState) + 1);}
	else if player(1), map(bbtag_rollOrder) = 4 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 2, player(1), map(bbtag_teamIntroState) - 1, player(1), map(bbtag_teamIntroState) + 1);}

	if (player(1), map(bbtag_teamIntroState) > cond(teamMode = turns,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 1)
	|| (player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 2)
	|| ((player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 3 && player(1), map(bbtag_introState) = 1) || (player(1), map(bbtag_teamIntroState) > cond(teamMode = turns,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 3 && player(1), map(bbtag_introState) = 2))
	|| ((player(1), map(bbtag_teamIntroState) > cond(teamMode = turns,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 4 && player(1), map(bbtag_introState) = 1) || (player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 4 && player(1), map(bbtag_introState) = 2))
	{
		player(1), map(bbtag_introState) := cond(player(1), map(bbtag_rollOrder) = 4, cond(player(1), map(bbtag_introState) = 2,1,3),player(1), map(bbtag_introState) + 1);
		if player(1), map(bbtag_rollOrder) = 1 {player(1), map(bbtag_teamIntroState) := 1;}
		else if player(1), map(bbtag_rollOrder) = 2 {player(1), map(bbtag_teamIntroState) := cond(teamMode = turns,1,NumPartner + 1);}
		else if player(1), map(bbtag_rollOrder) = 3 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 1, cond(teamMode = turns,1,NumPartner + 1), 1);}
		else if player(1), map(bbtag_rollOrder) = 4 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 2, cond(teamMode = turns,1,NumPartner + 1), 1);}
	}
}


if roundstate = [-1, 1] && map(bbtag_specialIntro) = 1 && player(1), map(bbtag_specialIntroActive) > 0 && stateno = 0 && (time >= player(1), map(bbtag_pauseLength) || player(1), map(bbtag_pauseLength) = 0)
{
	player(1), map(bbtag_specialIntroActive) := player(1), map(bbtag_specialIntroActive) - 1;
}

if roundstate = [-1, 2] && player(1), map(bbtag_introState) = 3 && !isHelper && teamSide = [1,2]
{

	if player(1), map(bbtag_introMovement) && roundstate < 2
	{
		notHitBy{value: SCA} #just in case your character has damaging dashes or something
		shiftInput{input: a; output: none}
		shiftInput{input: b; output: none}
		shiftInput{input: c; output: none}
		shiftInput{input: x; output: none}
		shiftInput{input: y; output: none}
		shiftInput{input: z; output: none}
		if player(1), map(bbtag_introMovementTauntDisabled) {shiftInput{input: s; output: none}}
		if player(1), map(bbtag_introMovementTagDisabled)
		{
			shiftInput{input: d; output: none}
			shiftInput{input: w; output: none}
		}
		AssertSpecial{flag: NoIntroReset;flag2:NoAICheat;flag3:NoStandGuard;flag4:NoCrouchGuard;flag5:NoAirGuard;}
		if ailevel {map(ailevel_) := ailevel;}
		AssertSpecial{flag: NoAiLevel}
		if map(ailevel_) {
			let x = abs(p2bodydist x);
			# get close
			if $x >= const240p(70) {AssertInput{flag:F;}} # imported ai code from foobs' extended intro winpose module.
		}
		player(1), map(bbtag_introMovementActive) := 1;
	}
	else if player(1), map(bbtag_introMovement) && roundstate = 2 && player(1), map(bbtag_introMovementActive) = 1
	{
		shiftInput{input: none; output: none}
		player(1), map(bbtag_introMovementActive) := 0;
	}
}


if roundstate = [0,1] && playerno < 3 {	
	# mutes the music during round one.
	if player(1), map(bbtag_introMusicFirstRound) = 1 && roundno = 1 {assertspecial{flag:nomusic;}}

}


ignorehitpause if roundstate = 4 && !ishelper && playerno < 3 {
	# disables PotS characters' own zoom
	if authorname = "Phantom.of.the.Server" && map(cfg_winzoom) {map(cfg_winzoom):= 0;}
	
	# zoom zoom
	if ((player(1), map(bbtag_outroFocus) = 1 && (winko||wintime)) || (player(1), map(bbtag_outroFocus) = 2 && (loseko||losetime))) && player(1), map(bbtag_outroZoom) > 1 {
		let z = gamewidth/const240p(320/player(1), map(bbtag_outroZoom));
		zoom{scale:$z;lag:0.97; pos:(pos x/$z)*camerazoom, pos y; stagebound:1; camerabound:0;}
	}
}

# Outro Delay
ignorehitpause if roundstate >= 3 && !ishelper && playerno < 9
{
	# add code here
}

}
