# == BBTAG Intro Module v 1.0.5b == #
#
#	by dionednd
#
#	Commissioned by SkeleJ64
#

# == Changelog == #
#
#	v 0.0.1
#	- Implemented basic intro delay
#
#	v 0.0.2
#	- Added Camera parameters
#	- Fixed camera visual issues with characters that have off screen intros.
#
#	v 0.0.3
#	- Added roll orders 1 and 2
#
#	v 0.0.4
#	- Added roll orders 3 and 4
#
#	v 0.0.5
#	- Added special intro support
#
#	v 0.0.6
#	- Added music mute and winner/loser zoom from foobs' extended intro winpose module (go check out foobs' extended intro winpose module)
#
#	v 0.0.7
#	- Added off-screen intro support
#
#	v 0.0.8
#	- Fixed bug where the characters would be frozen at intro state
#
#	v 0.0.9
#	- Added Intro Movement
#
#	v 1.0.0 (Public Release)
#	- Fixed AI bugs from previous version
#	- Implemented simple AI from foobs' extended intro winpose module (go check out foobs' extended intro winpose module)
#
#	v 1.0.1
#	- Fixed an issue where players could damage each other during intro movement if a character has a movement option that can damage the enemy (like Merkava's Air Dash)
#	- Reduced the intro movement time to 3 seconds
#	- Fixed issue where the selected palette wasn't showing (idk why i didn't notice that this was being caused by my module and not a nightly bug)
#
#	v 1.0.2
#	- Added more compatibility for tag team mode. (non-team leader players will get out of the screen as soon as both teams' intros are played.)
#	- Disabled intro movement time for training mode. (isn't really needed there)
#	- Adjusted the camera during introstate = 3 to only apply whenever intro movement is over
#
#	v 1.0.3
#	- Added Stage Intros
#	- Added Stage Intro Scroll Order 1
#	- Added Delay before players do their intro
#	- Added Music Ducking during player intros (player(1), map(bbtag_introMusicFirstRound) = 2) (will add interpolation later)
#
#	v 1.0.3a
#	- Made stage intro camera smoother by adding camera lag. (will look rough if player(1), map(bbtag_IntroDelay) = 0?)
#	- Changed Duck Volume to 75%.
#	- Added Stage Name Text Support (only displays a placeholder text. will be fully implemented once strings are supported in IKEMEN GO.) (you can still use the implementation for your full games. that's the reason why i decided to add it)
#	- Started Outro Delay implimentation (no functionality yet)
#
#	v 1.0.4
#	- Made some stage compatibility changes (with camera.startzoom)
#	- Fixed an issue with Volume Ducking not working whenever special intros are detected
#	- Added Volume Ducking Interpolation
#	- Added Outro Delay
#	- Added Volume Ducking for Outros
#
#	v 1.0.4a
#	- disabled Stage Text by default. (forgot to)
#
#	v 1.0.5
#	- Fixed Bug where in the first round in tag team mode, partners couldn't be tagged in if the team leader got ko'd.
#	- Added Stage Intro Scroll Order 2 & 3
#	- Fixed Weird AI Walk bug?
#
#	v 1.0.5a
#	- Moved the module to -3 to make the module compatible with dynamic shadows module.
#
#	v 1.0.5b
#	- Made intro movement work on all rounds.

# == How To Install == #
#
#	1. Open your config.ini
#	2. look for States in [Common]
#	3. add ", data/intro_delay_specialintros.zss, data/intro_delay.zss" to your states.
#	4. make sure that intro_delay_specialintros.zss comes first before intro_delay.zss
#

# == Additional Notes == #
#
#	This module was tested with foobs' extended intro winpose module and isn't compatible with foobs' module.
#	This module wasn't made to compliment foobs' extended intro winpose module, so expect bugs when you're using both.
#	some features were imported into this module due to demand.
#
#	This module is incompatible with characters that have configurations in their state 5900.
#	Trying to fix the issue led me to breaking the module multiple times.
#	The Zoom SCTRL not working unless a match is properly loaded is still bugging me. idk how to fix it. i set the default stage intro scroll order to 3 due to this.

# == Functions == #

[Function IterateMembers(a,b,c) ret]
# a = current TeamOutroState
# b = Team Leader's MemberNo
# c = NumPartners

# must loop around team members once then skip to next team by returning $c + 1

[Function InterpolateValue(a,b,c) ret]

if $a != $b && $c > 0
{
	let ret = cond($a>$b, cond($a-$c < $b, $b,$a-$c), cond($a+$c > $b, $b,$a+$c));
}
else if $a = $b || $c < 1 {let ret = $a;}

# == Normal States == #

[StateDef 1800000; type: S; ctrl: 0; velset: 0, 0;]

if selfAnimExist(0) {
	changeAnim{value: 0}
}

if memberNo = player(1), map(bbtag_teamOutroState) && teamSide = player(1), map(bbtag_outroState) && player(1), map(bbtag_specialOutroActive) < 1 && (time >= player(1), map(bbtag_pauseLength) || player(1), map(bbtag_pauseLength) = 0)
{
	changeState{value: cond(!drawgame,cond(losetime,cond(Const(TimeOverState),Const(TimeOverState),170),cond(Const(PreOutroState),Const(PreOutroState),180)),cond(Const(DrawGameState),Const(DrawGameState),175))}
}

[StateDef 1900000; type: S; ctrl: 0; velset: 0, 0;]

if selfAnimExist(190) {
	changeAnim{value: 190}
}
else if selfAnimExist(191) {
	changeAnim{value: 191}
}

if memberNo = player(1), map(bbtag_teamIntroState) && teamSide = player(1), map(bbtag_introState) && player(1), map(bbtag_specialIntroActive) < 1 && (time >= player(1), map(bbtag_pauseLength) || player(1), map(bbtag_pauseLength) = 0)
&& (player(1), map(bbtag_stageIntroFinished) || !player(1), map(bbtag_stageIntro))
{
	changeState{value: cond(Const(PreIntroState),Const(PreIntroState),190)}
}

# == Global States == #

[StateDef -3]
ignorehitpause{
if playerno < 9 {
	if (player(1), map(bbtag_introMovement) || player(1), map(bbtag_introSkipDisabled) || player(1), map(bbtag_stageIntro)) && !isHelper && roundstate < 2
	{
		assertspecial{flag:roundnotskip;}
	}

ignorehitpause if roundState = [0,1] && !isHelper && teamSide != 0
{
	# Settings
	if roundstate = 0 && roundno = 1
	{
		# Roll Order
		# 1 = p1 - right to left / p2 - left to right
		# 2 = p1 - left to right / p2 - right to left
		# 3 = left to right for both teams (like in BBTAG)
		# 4 = right to left for both teams
		player(1), map(bbtag_rollOrder) := 3;

		# Pause (can be 0)
		player(1), map(bbtag_pauseLength) := 60;

		# Camera Lag
		player(1), map(bbtag_cameraLag) := 0.9;

		# Camera Zoom
		player(1), map(bbtag_cameraZoom) := 1.2;

		# Disable Intro Music for 1st Round 1  = Mute Music, 0 = Enable Music, 2 = Duck Music Volume during character intros
		player(1), map(bbtag_introMusicFirstRound) := 2;

		# Duck Volume
		player(1), map(bbtag_introMusicDuckVolume) := 75;

		# Duck Volume Interpolation Value
		player(1), map(bbtag_introMusicInterpolateValue) := 1; # 1 = smoothest. setting this value to 0 or less or a high value will disable interpolation. i suggest using 1-5.

		# Intro Movement 1 = On 0 = Off
		player(1), map(bbtag_introMovement) := 1;

		# Disable Taunting during Intro Movement (ignored if Intro Movement is off.) this option was added to prevent from players gaining advantage by taunting during intro, where the enemy can't attack them. however, if your characters somehow have no meter gain during taunts, you can enable this just for fun.
		player(1), map(bbtag_introMovementTauntDisabled) := 1;

		# Disable Switching Characters (Tag Team Mode Only) during Intro Movement (ignored if Intro Movement is off.)
		player(1), map(bbtag_introMovementTagDisabled) := 1;
		
		# Time for the players to move during intro. ignored if intro movement is disabled and Pause Length is taken instead.
		player(1), map(bbtag_introMovementTime) := 180;

		# Disable Intro Skip. always on whenever Intro Movement is on.
		player(1), map(bbtag_introSkipDisabled) := 1;

		# Enable Stage Intro.
		player(1), map(bbtag_stageIntro) := 1;

		# Stage Intro Scroll Order (Ignored if stage intro is disabled)
		# 1 = Zoom out from the center of the stage then start char intros (buggy, doesn't work at first try due to match not being initialized properly? idk)
		# 2 = Pan up from the underground then start char intros (edit camera.boundlow to something that's not 0 for this to work)
		# 3 = Pan down from the sky then start char intros (edit camera.boundhigh if you want the camera to start higher)
		player(1), map(bbtag_stageIntroScrollOrder) := 3;

		# Stage Intro Duration
		player(1), map(bbtag_stageIntroTime) := 240; #120 frames = 2 seconds

		# Stage Intro Zoom
		player(1), map(bbtag_stageIntroZoom) := 2.0;

		# Delay before any of the intros begin (ignored if stage intro is disabled)
		player(1), map(bbtag_IntroDelay) := 60; #60 frames = 1 second

		# Stage Text (Ignored if stage intro is disabled)
		player(1), map(bbtag_stageText) := 0; #disabled for now. it doesn't display the stage's name due to engine limitations. once we get support for strings, i'll update this feature

		# Stage Text Params
		player(1), map(bbtag_stageTextFont) := -1;
		player(1), map(bbtag_stageTextAlign) := 0;
		player(1), map(bbtag_stageTextScaleX) := 2;
		player(1), map(bbtag_stageTextScaleY) := 2;
		player(1), map(bbtag_stageTextLayerno) := 0;
		player(1), map(bbtag_stageTextPosX) := 160;
		player(1), map(bbtag_stageTextPosY) := 120;
		player(1), map(bbtag_stageTextColorR) := 256;
		player(1), map(bbtag_stageTextColorG) := 256;
		player(1), map(bbtag_stageTextColorB) := 256;

		# Outro Delay
		player(1), map(bbtag_outroDelay) := 1; # if enabled, outroFocus is ignored.

		# Outro Delay Roll Order	
		# 1 = Winners First (from p1), Losers Last (from p2), start with p1 team if tie
		# 2 = Losers First (from p2), Winners Last (from p1), start with p2 team if tie
		player(1), map(bbtag_outroRollOrder) := 1; # if enabled, outroFocus is ignored.
		
		# outro delay has no functionality yet.

		# Cam Focus on Character During Outro 0 = Off 1 = Winner 2 = Loser
		player(1), map(bbtag_outroFocus) := 1;

		# Cam Zoom during Outro >1 = Zoom in <1 = Zoom out
		player(1), map(bbtag_outroZoom) := 1.2;

		# outro music volume duck
		player(1), map(bbtag_outroMusicVolumeDuck) := 1;



		# sets the palette of the player
		RemapPal{source:1,1;dest:1,palno}
		# resets variables
		if roundsexisted = 0 && matchno = 1
		{
			VarRangeSet{value:0;}
			VarRangeSet{fvalue:0;}
		}
	}



	if player(1), map(bbtag_introMusicFirstRound) = 2 && !player(1), map(starting_volume) && roundstate = 0 && roundNo = 1
	{
		# i needed to add this due to StageVar(music.bgmvolume) not existing. will likely break if you have a module that modifies the bgm volume.
		player(1), map(starting_volume) := bgmVar(volume);
	}

	AssertSpecial{flag: NoBarDisplay}
	# Stage Intro
	if player(1), map(bbtag_stageIntro) && playerno = 1 && roundNo = 1
	{
		if !player(1), map(bbtag_stageIntroFinished){AssertSpecial{flag: Intro}}
		if !player(1), map(stageIntroTime) && !player(1), map(bbtag_stageIntroFinished) && !player(1), map(stageIntroBegun)
		{
			player(1), map(stageIntroBegun) := 1;
			player(1), map(stageIntroTime) := player(1), map(bbtag_stageIntroTime);
		} 

		if player(1), map(stageIntroTime) >= 0
		{
			let c = (256 -  (256*(player(1), map(stageIntroTime)/player(1), map(bbtag_stageIntroTime))));
			AllPalFX{mul: $c, $c, $c;time: 2}
			switch(player(1), map(bbtag_stageIntroScrollOrder))
			{
				case 1:
					let siz = gamewidth/const240p(320/(stageVar(camera.startzoom) + (player(1), map(bbtag_stageIntroZoom)*(player(1), map(stageIntroTime)/player(1), map(bbtag_stageIntroTime)))));
					zoom{scale:$siz;pos:(0/$siz)*camerazoom, 0;lag:cond(player(1), map(stageIntroTime) = player(1), map(bbtag_stageIntroTime), 0, player(1), map(bbtag_cameraLag));stagebound:1; camerabound:0}
				case 2:
					let pos = stageVar(camera.boundlow)*(player(1), map(stageIntroTime)/player(1), map(bbtag_stageIntroTime));
					zoom{scale:1.0;pos:(0/1.0)*camerazoom, $pos;lag:cond(player(1), map(stageIntroTime) = player(1), map(bbtag_stageIntroTime), 0, player(1), map(bbtag_cameraLag));stagebound:1; camerabound:0}
				case 3:
					let pos = stageVar(camera.boundhigh)*(player(1), map(stageIntroTime)/player(1), map(bbtag_stageIntroTime));
					zoom{scale:1.0;pos:(0/1.0)*camerazoom, $pos;lag:cond(player(1), map(stageIntroTime) = player(1), map(bbtag_stageIntroTime), 0, player(1), map(bbtag_cameraLag));stagebound:1; camerabound:0}
			}
		}
		if player(1), map(stageIntroTime) > (player(1), map(bbtag_IntroDelay) * -1)
		{
			# Stage Text
			if player(1), map(bbtag_stageText) && playerno = 1
			{
				if !NumText(135790)
				{
					text{text: "Third Heights";localcoord:320,240;layerno:player(1), map(bbtag_stageTextLayerno);font:player(1), map(bbtag_stageTextFont);align:player(1), map(bbtag_stageTextAlign);pos:player(1), map(bbtag_stageTextPosX), player(1), map(bbtag_stageTextPosY);scale:player(1), map(bbtag_stageTextScaleX),player(1), map(bbtag_stageTextScaleY);id:135790;textdelay:8;removetime:player(1), map(bbtag_stageIntroTime)+player(1), map(bbtag_IntroDelay);color:player(1), map(bbtag_stageTextColorR),player(1), map(bbtag_stageTextColorG),player(1), map(bbtag_stageTextColorB),0;}
				}
				else if NumText(135790) && player(1), map(stageIntroTime) > (player(1), map(bbtag_IntroDelay) * -1)
				{
					ModifyText{id:135790;color:player(1), map(bbtag_stageTextColorR),player(1), map(bbtag_stageTextColorG),player(1), map(bbtag_stageTextColorB), cond(player(1), map(stageIntroTime) <= 0, 256-(256*((player(1), map(stageIntroTime)*-1)/player(1), map(bbtag_IntroDelay))),(256 -  (256*(player(1), map(stageIntroTime)/player(1), map(bbtag_stageIntroTime)))));}
				}
			}

			if player(1), map(stageIntroTime) < 0
			{
				let fz = gamewidth/const240p(320/stageVar(camera.startzoom));
				zoom{scale:$fz;lag:player(1), map(bbtag_cameraLag); pos:(0/$siz)*camerazoom, 0; stagebound:1; camerabound:0}
			}
			player(1), map(stageIntroTime) := player(1), map(stageIntroTime) - 1;
		}

		if player(1), map(stageIntroTime) = (player(1), map(bbtag_IntroDelay) * -1) && !player(1), map(bbtag_stageIntroFinished) 
		{
			player(1), map(bbtag_stageIntroFinished) := 1;
		}

	}

	# DO NOT TOUCH THE NEXT LINES UNLESS YOU KNOW WHAT YOU'RE DOING.
	if map(bbtag_specialIntro) != 1 && roundno = 1 {call specialIntroCheck();}

	if player(1), map(checkSetIntro) != 1 && teamSide = cond(player(1), map(bbtag_rollOrder) = 4,2, 1) && memberNo = cond(player(1), map(bbtag_rollOrder) = 1,1, cond(teamMode = turns,1,NumPartner + 1)) && roundno = 1
	{
		if player(1), map(checkSetIntro) != 1{player(1), map(checkSetIntro) := 1;}
		player(1), map(bbtag_introState) := cond(player(1), map(bbtag_rollOrder) = 4,2, 1);
		player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_rollOrder) = 1,1, cond(teamMode = turns,1,NumPartner + 1));
	}

	if (player(1), map(bbtag_specialIntroActive) > 0 ||
	(teamSide = player(1), map(bbtag_introState) && (player(1), map(bbtag_stageIntroFinished) || !player(1), map(bbtag_stageIntro))
	&& memberNo = player(1), map(bbtag_teamIntroState))) && roundno = 1
	{
		# Music Volume Ducking
		if player(1), map(bbtag_introMusicFirstRound) = 2
		{
			let v = call InterpolateValue(bgmVar(volume),player(1), map(bbtag_introMusicDuckVolume),player(1), map(bbtag_introMusicInterpolateValue));
			ModifyBGM{volume:$v}
		}
	}

	if player(1), map(bbtag_introState) > 0 && player(1), map(bbtag_introState) < 3 && map(bbtag_specialIntro) != 1 && player(1), map(bbtag_specialIntroActive) < 1 && roundno = 1
	{

		AssertSpecial{flag: Intro}
		if teamSide = player(1), map(bbtag_introState) && (player(1), map(bbtag_stageIntroFinished) || !player(1), map(bbtag_stageIntro))
		{
			if memberNo = player(1), map(bbtag_teamIntroState)
			{
				# let them continue their animation and focus the camera on them
				let z = gamewidth/const240p(320/player(1), map(bbtag_cameraZoom));
				zoom{scale:$z;lag:player(1), map(bbtag_cameraLag); pos:(pos x/$z)*camerazoom, 0; stagebound:1; camerabound:0;}

				if stateno = 0 && (time >= player(1), map(bbtag_pauseLength) || player(1), map(bbtag_pauseLength) = 0)
				{
					map(bbtag_playerIntroFinished) := 1;
					if player(1), map(bbtag_rollOrder) = 1 {player(1), map(bbtag_teamIntroState) := player(1), map(bbtag_teamIntroState) + 1;}
					else if player(1), map(bbtag_rollOrder) = 2 {player(1), map(bbtag_teamIntroState) := player(1), map(bbtag_teamIntroState) - 1;}
					else if player(1), map(bbtag_rollOrder) = 3 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 1, player(1), map(bbtag_teamIntroState) - 1, player(1), map(bbtag_teamIntroState) + 1);}
					else if player(1), map(bbtag_rollOrder) = 4 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 2, player(1), map(bbtag_teamIntroState) - 1, player(1), map(bbtag_teamIntroState) + 1);}

					if (player(1), map(bbtag_teamIntroState) > cond(teamMode = turns,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 1)
					|| (player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 2)
					|| ((player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 3 && player(1), map(bbtag_introState) = 1) || (player(1), map(bbtag_teamIntroState) > cond(teamMode = turns,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 3 && player(1), map(bbtag_introState) = 2))
					|| ((player(1), map(bbtag_teamIntroState) > cond(teamMode = turns,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 4 && player(1), map(bbtag_introState) = 1) || (player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 4 && player(1), map(bbtag_introState) = 2))
					{
						player(1), map(bbtag_introState) := cond(player(1), map(bbtag_rollOrder) = 4, cond(player(1), map(bbtag_introState) = 2,1,3),player(1), map(bbtag_introState) + 1);
						if player(1), map(bbtag_rollOrder) = 1 {player(1), map(bbtag_teamIntroState) := 1;}
						else if player(1), map(bbtag_rollOrder) = 2 {player(1), map(bbtag_teamIntroState) := cond(teamMode = turns,1,NumPartner + 1);}
						else if player(1), map(bbtag_rollOrder) = 3 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 1, cond(teamMode = turns,1,NumPartner + 1), 1);}
						else if player(1), map(bbtag_rollOrder) = 4 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 2, cond(teamMode = turns,1,NumPartner + 1), 1);}
					}
				}
			}
			else if map(bbtag_playerIntroFinished) != 1
			{
				ChangeState{value:1900000; continue:0}
			}
		}
		else if map(bbtag_playerIntroFinished) != 1 && roundno = 1
		{
			ChangeState{value:1900000; continue:0}
		}
	}

	if player(1), map(bbtag_introState) = 3 || roundno > 1 && roundstate = 1
	{
		# Music Volume Ducking
		if player(1), map(bbtag_introMusicFirstRound) = 2 && roundno = 1
		{
			let v = call InterpolateValue(bgmVar(volume),player(1), map(starting_volume),player(1), map(bbtag_introMusicInterpolateValue));
			ModifyBGM{volume:$v}
		}

		if player(1), map(introMovementTime) = 0 && player(1), map(introMovementTimeFinished) = 0 && player(1), map(bbtag_introMovement)
		{
			player(1), map(introMovementTime) := player(1), map(bbtag_introMovementTime);
		}
		if !ctrl && stateno = 0 && (time >= player(1), map(bbtag_pauseLength) || player(1), map(bbtag_pauseLength) = 0) && player(1), map(bbtag_introMovement)
		{
			ctrlSet{value: 1}
			if teamMode = Tag{map(_iksys_tagIntroFlag) := 1;}
			if TeamLeader != playerno && teamMode = Tag
			{
				if !standby {tagOut{stateno: const(StateTagLeavingScreen)}}
			}
		}
		
		if player(1), map(bbtag_specialIntroActive) < 1 && player(1), map(introMovementTimeFinished) = 0 && roundstate < 2 && (player(1), map(bbtag_stageIntroFinished) || !player(1), map(bbtag_stageIntro)) && roundno = 1
		{
			let z = gamewidth/const240p(320/stageVar(camera.startzoom));
			zoom{scale:$z;lag:player(1), map(bbtag_cameraLag);stagebound:1;}
		}
		if player(1), map(introMovementTime) > 0 && player(1), map(bbtag_introMovement)
		{
			AssertSpecial{flag: Intro}
			
			if playerno = 1 {player(1), map(introMovementTime) := player(1), map(introMovementTime) - 1;}
			if playerno = 1 && gamemode = "training" {player(1), map(introMovementTime) := 0;}
			if player(1), map(introMovementTime) = 0 && player(1), map(introMovementTimeFinished) = 0 {player(1), map(introMovementTimeFinished) := 1;}
		}
	}

	if player(1), map(bbtag_specialIntroActive) > 0 && stateno != 19000000 && map(bbtag_specialIntro) != 1 && roundno = 1
	{
		ChangeState{value:1900000; continue:0}
	}

}

if roundstate = [-1, 1] && map(bbtag_specialIntro) = 1 && memberNo = player(1), map(bbtag_teamIntroState) && teamSide = player(1), map(bbtag_introState) && !isHelper && player(1), map(bbtag_specialIntroActive) = 0 && roundno = 1
{
	map(bbtag_playerIntroFinished) := 1;
	if player(1), map(bbtag_rollOrder) = 1 {player(1), map(bbtag_teamIntroState) := player(1), map(bbtag_teamIntroState) + 1;}
	else if player(1), map(bbtag_rollOrder) = 2 {player(1), map(bbtag_teamIntroState) := player(1), map(bbtag_teamIntroState) - 1;}
	else if player(1), map(bbtag_rollOrder) = 3 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 1, player(1), map(bbtag_teamIntroState) - 1, player(1), map(bbtag_teamIntroState) + 1);}
	else if player(1), map(bbtag_rollOrder) = 4 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 2, player(1), map(bbtag_teamIntroState) - 1, player(1), map(bbtag_teamIntroState) + 1);}

	if (player(1), map(bbtag_teamIntroState) > cond(teamMode = turns,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 1)
	|| (player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 2)
	|| ((player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 3 && player(1), map(bbtag_introState) = 1) || (player(1), map(bbtag_teamIntroState) > cond(teamMode = turns,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 3 && player(1), map(bbtag_introState) = 2))
	|| ((player(1), map(bbtag_teamIntroState) > cond(teamMode = turns,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 4 && player(1), map(bbtag_introState) = 1) || (player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 4 && player(1), map(bbtag_introState) = 2))
	{
		player(1), map(bbtag_introState) := cond(player(1), map(bbtag_rollOrder) = 4, cond(player(1), map(bbtag_introState) = 2,1,3),player(1), map(bbtag_introState) + 1);
		if player(1), map(bbtag_rollOrder) = 1 {player(1), map(bbtag_teamIntroState) := 1;}
		else if player(1), map(bbtag_rollOrder) = 2 {player(1), map(bbtag_teamIntroState) := cond(teamMode = turns,1,NumPartner + 1);}
		else if player(1), map(bbtag_rollOrder) = 3 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 1, cond(teamMode = turns,1,NumPartner + 1), 1);}
		else if player(1), map(bbtag_rollOrder) = 4 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 2, cond(teamMode = turns,1,NumPartner + 1), 1);}
	}
}


if roundstate = [-1, 1] && map(bbtag_specialIntro) = 1 && player(1), map(bbtag_specialIntroActive) > 0 && stateno = 0 && (time >= player(1), map(bbtag_pauseLength) || player(1), map(bbtag_pauseLength) = 0) && roundno = 1
{
	player(1), map(bbtag_specialIntroActive) := player(1), map(bbtag_specialIntroActive) - 1;
}

if roundstate = [-1, 2] && (player(1), map(bbtag_introState) = 3 || (roundno > 1 && roundstate = 1)) && !isHelper && teamSide = [1,2]
{

	if player(1), map(bbtag_introMovement) && roundstate < 2
	{
		notHitBy{value: SCA} #just in case your character has damaging dashes or something
		shiftInput{input: a; output: none}
		shiftInput{input: b; output: none}
		shiftInput{input: c; output: none}
		shiftInput{input: x; output: none}
		shiftInput{input: y; output: none}
		shiftInput{input: z; output: none}
		if player(1), map(bbtag_introMovementTauntDisabled) {shiftInput{input: s; output: none}}
		if player(1), map(bbtag_introMovementTagDisabled)
		{
			shiftInput{input: d; output: none}
			shiftInput{input: w; output: none}
		}
		AssertSpecial{flag: NoIntroReset;flag2:NoAICheat;flag3:NoStandGuard;flag4:NoCrouchGuard;flag5:NoAirGuard;}
		if ailevel {map(ailevel_) := ailevel;}
		AssertSpecial{flag: NoAiLevel}
		if map(ailevel_) {
			let x = abs(p2bodydist x);
			# get close
			if $x >= const240p(70) && map(walking_) < 2
			{
				AssertInput{flag:F;}
				map(walking) := 1;
			} # imported ai code from foobs' extended intro winpose module.
			else
			{
				if $x < const240p(70)
				{
					map(walking) := 2;
				}
				else if $x >= const240p(70) && map(walking_) = 2 && time % 60 = 0
				{
					map(walking) := 0;
				}
			}
		}
		player(1), map(bbtag_introMovementActive) := 1;
	}
	else if player(1), map(bbtag_introMovement) && roundstate = 2 && player(1), map(bbtag_introMovementActive) = 1
	{
		shiftInput{input: none; output: none}
		player(1), map(bbtag_introMovementActive) := 0;
	}
}


if roundstate = [0,1] && playerno < 3 {	
	# mutes the music during round one.
	if player(1), map(bbtag_introMusicFirstRound) = 1 && roundno = 1 {assertspecial{flag:nomusic;}}

}


ignorehitpause if roundstate = 4 && !ishelper && playerno < 3 && !player(1), map(bbtag_outroDelay) {
	# disables PotS characters' own zoom
	if authorname = "Phantom.of.the.Server" && map(cfg_winzoom) {map(cfg_winzoom):= 0;}
	
	# zoom zoom
	if ((player(1), map(bbtag_outroFocus) = 1 && (winko||wintime)) || (player(1), map(bbtag_outroFocus) = 2 && (loseko||losetime))) && player(1), map(bbtag_outroZoom) > 1 {
		let z = gamewidth/const240p(320/player(1), map(bbtag_outroZoom));
		zoom{scale:$z;lag:0.97; pos:(pos x/$z)*camerazoom, pos y; stagebound:1; camerabound:0;}
	}
}

}

# Outro Delay
ignorehitpause if roundstate >= 4 && !ishelper && playerno < 9 && teamSide != 0 && player(1), map(bbtag_outroDelay)
{
	# disables PotS characters' own zoom
	if authorname = "Phantom.of.the.Server" && map(cfg_winzoom) {map(cfg_winzoom):= 0;}

	# add code here
	if !player(1), map(bbtag_outroState) && !player(1), map(bbtag_teamOutroState) & playerno = 1
	{
		player(1), map(bbtag_outroState) := cond(!drawgame, cond(player(1), map(bbtag_outroRollOrder) = 1,cond(win,teamSide,enemy,teamSide), cond(lose||losetime,teamSide,enemy,teamSide)), map(bbtag_outroRollOrder));
		player(1), map(bbtag_teamOutroState) := 1;
	}

	if (player(1), map(bbtag_specialOutroActive) > 0 ||
	(teamSide = player(1), map(bbtag_outroState) && memberNo = player(1), map(bbtag_teamOutroState)))
	{
		# Music Volume Ducking
		if player(1), map(bbtag_outroMusicVolumeDuck) = 1
		{
			let v = call InterpolateValue(bgmVar(volume),player(1), map(bbtag_introMusicDuckVolume),player(1), map(bbtag_introMusicInterpolateValue));
			ModifyBGM{volume:$v}
		}
	}

	if player(1), map(bbtag_outroState) > 0 && player(1), map(bbtag_outroState) < 3 && map(bbtag_specialOutro) != 1 && player(1), map(bbtag_specialOutroActive) < 1
	{
		if teamSide = player(1), map(bbtag_outroState)
		{
			if memberNo = player(1), map(bbtag_teamOutroState)
			{
				if !map(bbtag_playerOutroFinished) && stateno != 1800000 && stateno = 0{ChangeState{value:1800000; continue:0}}

				# let them continue their animation and focus the camera on them
				AssertSpecial{flag: roundNotOver}
				let z = gamewidth/const240p(320/player(1), map(bbtag_outroZoom));
				zoom{scale:$z;lag:player(1), map(bbtag_cameraLag); pos:(pos x/$z)*camerazoom, 0; stagebound:1; camerabound:0;}

				if (animtime = 0 || (AnimElemVar(Time) < 0 && AnimElemTime(AnimElemNo(0)) >= 60) || !alive)
				{
					map(bbtag_playerOutroFinished) := 1;
					player(1), map(bbtag_teamOutroState) := player(1), map(bbtag_teamOutroState) + 1;

					if player(1), map(bbtag_teamOutroState) > cond(teamMode = turns,1,NumPartner + 1)
					{
						if !drawgame
						{
							if player(1), map(bbtag_outroRollOrder) = 1
							{
								if win {player(1), map(bbtag_outroState) := enemy, teamSide;}else{player(1), map(bbtag_outroState) := 3;}
							}
							else if player(1), map(bbtag_outroRollOrder) = 2
							{
								if lose {player(1), map(bbtag_outroState) := enemy, teamSide;}else{player(1), map(bbtag_outroState) := 3;}
							}
						}
						else if drawgame
						{
							player(1), map(bbtag_outroState) := cond(player(1), map(bbtag_outroRollOrder) = 1, cond(player(1), map(bbtag_outroState) = 1, 2, 3),cond(player(1), map(bbtag_outroState) = 2, 1, 3));
						}
						player(1), map(bbtag_teamOutroState) := 1;
					}
				}
			}
			else if map(bbtag_playerOutroFinished) != 1 && alive && map(bbtag_specialOutro) != 1
			{
				ChangeState{value:1800000; continue:0}
			}
		}
		else if map(bbtag_playerOutroFinished) != 1 && alive && map(bbtag_specialOutro) != 1
		{
			ChangeState{value:1800000; continue:0}
		}
	}
	if player(1), map(bbtag_outroState) = 3
	{
		# Music Volume Ducking
		if player(1), map(bbtag_outroMusicVolumeDuck) = 1
		{
			let v = call InterpolateValue(bgmVar(volume),player(1), map(starting_volume),player(1), map(bbtag_introMusicInterpolateValue));
			ModifyBGM{volume:$v}
		}

		if player(1), map(bbtag_specialOutroActive) < 1
		{
			let z = gamewidth/const240p(320/stageVar(camera.startzoom));
			zoom{scale:$z;lag:player(1), map(bbtag_cameraLag);stagebound:1;}
		}
	}
	if map(bbtag_specialOutro) = 1 && (animtime = 0 || (AnimElemVar(Time) < 0 && AnimElemTime(AnimElemNo(0)) >= 60)) && player(1), map(bbtag_specialOutroActive) > 1 && stateno != 0
	{
		map(bbtag_specialOutro) := 0;
		player(1), map(bbtag_specialOutroActive) := player(1), map(bbtag_specialOutroActive) - 1;
	}
}
if roundstate = 3 && !isHelper && playerno < 9 
{
	#reset intro delay values
	if player(1), map(checkSetIntro) = 1{player(1), map(checkSetIntro) := 0;}
	map(bbtag_playerIntroFinished) := 0;
	map(bbtag_specialIntro) := 0;
	player(1), map(bbtag_specialIntroActive) := 0;
	player(1), map(introMovementTimeFinished) := 0;
	player(1), map(bbtag_stageIntroFinished) := 1;
	if teamSide = cond(player(1), map(bbtag_rollOrder) = 4,2, 1) && memberNo = cond(player(1), map(bbtag_rollOrder) = 1,1, cond(teamMode = turns,1,NumPartner + 1))
	{
		player(1), map(bbtag_introState) := cond(player(1), map(bbtag_rollOrder) = 4,2, 1);
		player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_rollOrder) = 1,1, cond(teamMode = turns,1,NumPartner + 1));
	}
	# intros still don't work during round 2 (maybe because assertspecial intro doesn't work if roundno > 1?)
	# will look into this later on.
	

	#reset outro delay values
	#call specialOutroCheck();
	player(1), map(bbtag_outroState) := 0;
	player(1), map(bbtag_teamOutroState) := 0;
	map(bbtag_playerOutroFinished) := 0;
	map(bbtag_specialOutro) := 0;
	player(1), map(bbtag_specialOutroActive) := 0;
}
}
