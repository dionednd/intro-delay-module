# == BBTAG Intro Module v 1.0.7b == #
#
#	by dionednd
#
#	Commissioned by SkeleJ64
#

# == Changelog == #
#
#	v 0.0.1
#	- Implemented basic intro delay
#
#	v 0.0.2
#	- Added Camera parameters
#	- Fixed camera visual issues with characters that have off screen intros.
#
#	v 0.0.3
#	- Added roll orders 1 and 2
#
#	v 0.0.4
#	- Added roll orders 3 and 4
#
#	v 0.0.5
#	- Added special intro support
#
#	v 0.0.6
#	- Added music mute and winner/loser zoom from foobs' extended intro winpose module (go check out foobs' extended intro winpose module)
#
#	v 0.0.7
#	- Added off-screen intro support
#
#	v 0.0.8
#	- Fixed bug where the characters would be frozen at intro state
#
#	v 0.0.9
#	- Added Intro Movement
#
#	v 1.0.0 (Public Release)
#	- Fixed AI bugs from previous version
#	- Implemented simple AI from foobs' extended intro winpose module (go check out foobs' extended intro winpose module)
#
#	v 1.0.1
#	- Fixed an issue where players could damage each other during intro movement if a character has a movement option that can damage the enemy (like Merkava's Air Dash)
#	- Reduced the intro movement time to 3 seconds
#	- Fixed issue where the selected palette wasn't showing (idk why i didn't notice that this was being caused by my module and not a nightly bug)
#
#	v 1.0.2
#	- Added more compatibility for tag team mode. (non-team leader players will get out of the screen as soon as both teams' intros are played.)
#	- Disabled intro movement time for training mode. (isn't really needed there)
#	- Adjusted the camera during introstate = 3 to only apply whenever intro movement is over
#
#	v 1.0.3
#	- Added Stage Intros
#	- Added Stage Intro Scroll Order 1
#	- Added Delay before players do their intro
#	- Added Music Ducking during player intros (player(1), map(bbtag_introMusicFirstRound) = 2) (will add interpolation later)
#
#	v 1.0.3a
#	- Made stage intro camera smoother by adding camera lag. (will look rough if player(1), map(bbtag_IntroDelay) = 0?)
#	- Changed Duck Volume to 75%.
#	- Added Stage Name Text Support (only displays a placeholder text. will be fully implemented once strings are supported in IKEMEN GO.) (you can still use the implementation for your full games. that's the reason why i decided to add it)
#	- Started Outro Delay implimentation (no functionality yet)
#
#	v 1.0.4
#	- Made some stage compatibility changes (with camera.startzoom)
#	- Fixed an issue with Volume Ducking not working whenever special intros are detected
#	- Added Volume Ducking Interpolation
#	- Added Outro Delay
#	- Added Volume Ducking for Outros
#
#	v 1.0.4a
#	- disabled Stage Text by default. (forgot to)
#
#	v 1.0.5
#	- Fixed Bug where in the first round in tag team mode, partners couldn't be tagged in if the team leader got ko'd.
#	- Added Stage Intro Scroll Order 2 & 3
#	- Fixed Weird AI Walk bug?
#
#	v 1.0.5a
#	- Moved the module to -3 to make the module compatible with dynamic shadows module.
#
#	v 1.0.5b
#	- Gave functionality for intro movement to work on all rounds.
#
#	v 1.0.5c
#	- Improved Interpolation code for volume ducking. also made it so that the volume wouldn't raise if the starting volume was 0.
#	- removed time condition during stateno = 0 to try to fix a bug.
#
#	v1.0.6
#	- Added Lose Pose if loser hasn't lost the match yet.
#	- replaced camera.startzoom with 1.0 (yeah, i didn't realize that the zoom sctrl would multiply the startzoom. since zoom just multiplies camerazoom instead of modifying camerazoom.)
#
#	v1.0.6a
#	- Fixed issue with state 5900.
#
#	v1.0.6b
#	- Fixed Volume Interpolation
#	- Changed Duck Volume to be a float. 1.0 means 100% of the starting volume, 0.5 means 50%. this was done for the volume ducking to be more compatible with the currently playing music instead of hardcoding a volume.
#	- Fixed bugs with outro
#	- Fixed Stand up animation on lose pose
#	- Changed losepose into continue screen animation, so the character doesn't talk about losing time or whatever.
#
#	v1.0.7
#	- Disabled Losepose for turns teammode.
#	- Fixed Intros & Outros for turns teammode.
#	- Added Intros for rounds > 1. (in turns teammode, intros for rounds > 1 work differently. if your character doesn't have an intro for rounds > 1 in turns team mode, that character is skipped.)
#	- Normalized a bunch of zoom code.
#	- Increased outro delay compatibility for tag mode.
#	- Fixed some bugs with volume ducking setting the volume incorrectly if outro was skipped.
#
#	v1.0.7a
#	- Added the option to disable intro delay for rounds > 1 (player(1), map(bbtag_introFirstRoundOnly). 0 by default. change to 1 to disable intros for rounds > 1)
#	- Added Function that checks whether previous intro state was an intro state. the module no longer needs to only check 170-199.
#	- Fixed workaround on tag team mode that prevents the standby player from doing their losepose. now, as long as the player is within stage bounds, the player will do their losepose.
#	- Fixed intro movement having a 1 frame window that allows attack inputs.
#	- Fixed losepose not ending the round if the animation has a frame that lasts -1 frames.
#
#	v1.0.7b
#	- Made the module not function for the training mode (got the idea from CD2)
#	
# == How To Install == #
#
#	1. Open your config.ini
#	2. look for States in [Common]
#	3. add ", data/intro_delay_specialintros.zss, data/intro_delay.zss" to your states.
#	4. make sure that intro_delay_specialintros.zss comes first before intro_delay.zss
#

# == Additional Notes == #
#
#	This module was tested with foobs' extended intro winpose module and isn't compatible with foobs' module.
#	This module wasn't made to compliment foobs' extended intro winpose module, so expect bugs when you're using both.
#	some features were imported into this module due to demand.
#
#	The Zoom SCTRL not working in the first match is a known ikemen go bug, Do not come to me to report this.

# == Functions == #

[Function isPreviousStateIntro()]
ignorehitpause if roundstate = 1
{
	if isAsserted(intro) #&& stateno != 1900000 && stateno != 5900 && stateno != 0
	{
		map(introstate) := stateno;
	}
	if map(introstate) != 0
	{
		if prevstateno = map(introstate)
		{
			map(isprevstatenointro) := 1;
		}
		else
		{
			map(isprevstatenointro) := 0;
		}
	}
}

[Function InterpolateValue(min, max, tick, ticks, mode) ret]

let t = float($tick) / float($ticks);
let t = cond($t > 1.0, 1.0, cond($t < 0.0, 0.0, $t));

if $mode = 1
{
    let easedT = $t ^ 3;                      # ease in
}
else if $mode = 2
{
    let easedT = 1.0 - (1.0 - $t) ^ 3;        # ease out
}
else if $mode = 3
{
    let easedT = cond(
        $t < 0.5,
        1.0 - (1.0 - $t) ^ 3,
        $t ^ 3
    );
}
else
{
    let easedT = $t;                          # linear
}

let ret = $min + ($max - $min) * cond($easedT > 1.0, 1.0, cond($easedT < 0.0, 0.0, $easedT));

[Function IkSys_SelfAnimExistAddMod10(cond, base) ret]
let ret = cond($cond && selfAnimExist($base + anim % 10),
	$base + anim % 10, $base);

# == Normal States == #

[StateDef 1800000; type: S; ctrl: 0; velset: 0, 0;]

if selfAnimExist(0) && alive && (anim != 0 || (anim = 0 && animtime = 0)) {
	changeAnim{value: 0}
}
if !alive {
	if cond((teammode = Turns || teammode = Single), 1, memberNo) = player(1), map(bbtag_teamOutroState) && teamSide = player(1), map(bbtag_outroState) && player(1), map(bbtag_specialOutroActive) < 1 && !p2, decisiveRound
	{
		if (anim = [5140, 5159] || anim = [5110, 5119]) && anim != 12 && selfAnimExist(12)
		{
			changeAnim{value:12}
		}
		else if anim = 12 && anim != 0 && selfAnimExist(0) && animtime = 0
		{
			changeAnim{value:0}
		}
		else if anim = 0
		{
			changeState{value:cond(Const(LosePoseState),Const(LosePoseState),5500)}
		}
	}
	else
	{
		let a = call IkSys_SelfAnimExistAddMod10(anim = [5111, 5119] || anim = [5171, 5179], 5140);
		if selfAnimExist($a) {
			changeAnim{value: $a}
		}
		if anim != [5140, 5159] && anim != [5110, 5119] {
			changeAnim{value: 5110}
		}
	}
}

if cond((teammode = Turns || teammode = Single), 1, memberNo) = player(1), map(bbtag_teamOutroState) && teamSide = player(1), map(bbtag_outroState) && player(1), map(bbtag_specialOutroActive) < 1 && (time >= player(1), map(bbtag_pauseLength) || player(1), map(bbtag_pauseLength) = 0) && alive
{
	changeState{value: cond(!drawgame,cond(losetime,cond(Const(TimeOverState),Const(TimeOverState),170),cond(win,cond(Const(PreOutroState),Const(PreOutroState),180),cond(Const(LosePoseState),Const(LosePoseState),5500))),cond(Const(DrawGameState),Const(DrawGameState),175))}
}


[StateDef 1900000; type: S; ctrl: 0; velset: 0, 0;]

if selfAnimExist(190) {
	changeAnim{value: 190}
}
else if selfAnimExist(191) {
	changeAnim{value: 191}
}

if cond((teammode = Turns || teammode = Single), 1, memberNo) = player(1), map(bbtag_teamIntroState) && teamSide = player(1), map(bbtag_introState) && player(1), map(bbtag_specialIntroActive) < 1 && (time >= player(1), map(bbtag_pauseLength) || player(1), map(bbtag_pauseLength) = 0)
&& cond(roundno = 1,(player(1), map(bbtag_stageIntroFinished) || !player(1), map(bbtag_stageIntro)),1)
{
	changeState{value: cond(Const(PreIntroState),Const(PreIntroState),cond(((teammode = Single && roundsexisted = roundno-1) || teammode = Simul || teammode = Tag) && roundsexisted > 0,190,5900))} #jump to 5900 / 190
}

[Statedef 9000800; type: S; ctrl: 0; velset: 0, 0;]
#placeholder state
AssertSpecial{flag:invisible}
notHitBy{value: SCA}

# == Global States == #

[StateDef -3]
ignorehitpause if gamemode != "training" {
if playerno < 9 {
	if (player(1), map(bbtag_introMovement) || player(1), map(bbtag_introSkipDisabled) || player(1), map(bbtag_stageIntro)) && !isHelper && roundstate < 2
	{
		assertspecial{flag:roundnotskip;}
	}

ignorehitpause if roundState = [0,1] && !isHelper && teamSide != 0
{
	# Settings
	if roundstate = 0
	{
		# Roll Order
		# 1 = p1 - right to left / p2 - left to right
		# 2 = p1 - left to right / p2 - right to left
		# 3 = left to right for both teams (like in BBTAG)
		# 4 = right to left for both teams
		player(1), map(bbtag_rollOrder) := 3;

		player(1), map(bbtag_introFirstRoundOnly) := 0;

		# Pause (can be 0)
		player(1), map(bbtag_pauseLength) := 60;

		# Camera Lag
		player(1), map(bbtag_cameraLag) := 0.9;

		# Camera Zoom
		player(1), map(bbtag_cameraZoom) := 1.2;

		# Disable Intro Music for 1st Round 1  = Mute Music, 0 = Enable Music, 2 = Duck Music Volume during character intros
		player(1), map(bbtag_introMusicFirstRound) := 2;

		# Duck Volume
		player(1), map(bbtag_introMusicDuckVolume) := 0.75;

		# Duck Volume Interpolation Value
		player(1), map(bbtag_introMusicInterpolateMode) := 3; # Interpolation Mode. ( 0 = off, 1 = ease in, 2 = ease out, 3 = ease in & out)

		# Intro Movement 1 = On 0 = Off
		player(1), map(bbtag_introMovement) := 1;

		# Disable Taunting during Intro Movement (ignored if Intro Movement is off.) this option was added to prevent from players gaining advantage by taunting during intro, where the enemy can't attack them. however, if your characters somehow have no meter gain during taunts, you can enable this just for fun.
		player(1), map(bbtag_introMovementTauntDisabled) := 1;

		# Disable Switching Characters (Tag Team Mode Only) during Intro Movement (ignored if Intro Movement is off.)
		player(1), map(bbtag_introMovementTagDisabled) := 1;
		
		# Time for the players to move during intro. ignored if intro movement is disabled and Pause Length is taken instead.
		player(1), map(bbtag_introMovementTime) := 180;

		# Disable Intro Skip. always on whenever Intro Movement is on.
		player(1), map(bbtag_introSkipDisabled) := 1;

		# Enable Stage Intro.
		player(1), map(bbtag_stageIntro) := 1;

		# Stage Intro Scroll Order (Ignored if stage intro is disabled)
		# 1 = Zoom out from the center of the stage then start char intros (buggy, doesn't work at first try due to match not being initialized properly? idk)
		# 2 = Pan up from the underground then start char intros (edit camera.boundlow to something that's not 0 for this to work)
		# 3 = Pan down from the sky then start char intros (edit camera.boundhigh if you want the camera to start higher)
		player(1), map(bbtag_stageIntroScrollOrder) := 3;

		# Stage Intro Duration
		player(1), map(bbtag_stageIntroTime) := 240; #120 frames = 2 seconds

		# Stage Intro Zoom
		player(1), map(bbtag_stageIntroZoom) := 2.0;

		# Delay before any of the intros begin (ignored if stage intro is disabled)
		player(1), map(bbtag_IntroDelay) := 60; #60 frames = 1 second

		# Stage Text (Ignored if stage intro is disabled)
		player(1), map(bbtag_stageText) := 0; #disabled for now. it doesn't display the stage's name due to engine limitations. once we get support for strings, i'll update this feature

		# Stage Text Params
		player(1), map(bbtag_stageTextFont) := -1;
		player(1), map(bbtag_stageTextAlign) := 0;
		player(1), map(bbtag_stageTextScaleX) := 2;
		player(1), map(bbtag_stageTextScaleY) := 2;
		player(1), map(bbtag_stageTextLayerno) := 0;
		player(1), map(bbtag_stageTextPosX) := 160;
		player(1), map(bbtag_stageTextPosY) := 120;
		player(1), map(bbtag_stageTextColorR) := 256;
		player(1), map(bbtag_stageTextColorG) := 256;
		player(1), map(bbtag_stageTextColorB) := 256;

		# Outro Delay
		player(1), map(bbtag_outroDelay) := 1; # if enabled, outroFocus is ignored.

		# Outro Delay Roll Order	
		# 1 = Winners First (from p1), Losers Last (from p2), start with p1 team if tie
		# 2 = Losers First (from p2), Winners Last (from p1), start with p2 team if tie
		player(1), map(bbtag_outroRollOrder) := 1; # if enabled, outroFocus is ignored.

		# Cam Focus on Character During Outro 0 = Off 1 = Winner 2 = Loser
		player(1), map(bbtag_outroFocus) := 1;

		# Cam Zoom during Outro >1 = Zoom in <1 = Zoom out
		player(1), map(bbtag_outroZoom) := 1.2;

		# outro music volume duck
		player(1), map(bbtag_outroMusicVolumeDuck) := 1;

		

		# sets the palette of the player
		# resets variables
		if roundsexisted = 0
		{
			RemapPal{source:1,1;dest:1,palno}
			VarRangeSet{value:0;}
			VarRangeSet{fvalue:0;}
		}
	}

	if roundstate = 0
	&& (player(1), map(interp_tick1) > 60
	|| player(1), map(interp_tick2) > 60
	|| player(1), map(interp_tick3) > 60
	|| player(1), map(interp_tick4) > 60)
	{
		player(1), map(interp_tick1) := 0;
		player(1), map(interp_tick2) := 0;
		player(1), map(interp_tick3) := 0;
		player(1), map(interp_tick4) := 0;
	}

	if playerno = 1 && numhelper(9000800) = 0
	{
		Helper
		{
			name: "Intro AssertSpecial";
			ID: 9000800;
			stateno: 9000800;
			pos: 0,0,0;
			postype: p1;
			keyctrl:0;
			supermovetime:-1;
			pausemovetime:-1;
		}
	}

	if player(1), map(bbtag_introMusicFirstRound) = 2 && !player(1), map(starting_volume) && roundstate = 0
	{
		# i needed to add this due to StageVar(music.bgmvolume) not existing. will likely break if you have a module that modifies the bgm volume.
		player(1), map(starting_volume) := bgmVar(volume);
	}

	if roundstate = 0 && (((teammode = Single && roundsexisted = roundno-1) || teammode = Simul || teammode = Tag) || roundno = 1) {ModifyBGM{volume:player(1), map(starting_volume)}}

	if player(1), map(bbtag_introState) < 3 {AssertSpecial{flag: NoBarDisplay}} # show lifebars during round announcement and forwards

	# Stage Intro
	if player(1), map(bbtag_stageIntro) && playerno = 1 && roundNo = 1
	{
		if !player(1), map(bbtag_stageIntroFinished){AssertSpecial{flag: Intro;redirectid:player(1), helper(9000800), id}}
		if !player(1), map(bbtag_stageIntroFinished) && !player(1), map(stageIntroBegun)
		{
			player(1), map(stageIntroBegun) := 1;
			player(1), map(stageIntroTime) := player(1), map(bbtag_stageIntroTime);
		} 

		if player(1), map(stageIntroTime) >= 0
		{
			let c = (256 -  (256*(player(1), map(stageIntroTime)/player(1), map(bbtag_stageIntroTime))));
			AllPalFX{mul: $c, $c, $c;time: 2}
			switch(player(1), map(bbtag_stageIntroScrollOrder))
			{
				case 1:
					let siz = gamewidth/const240p(320/1.0 + (player(1), map(bbtag_stageIntroZoom)*(player(1), map(stageIntroTime)/player(1), map(bbtag_stageIntroTime))));
					zoom{scale:$siz;pos:$siz*camerazoom, 0;lag:cond(player(1), map(stageIntroTime) = player(1), map(bbtag_stageIntroTime), 0, player(1), map(bbtag_cameraLag));stagebound:1; camerabound:0}
				case 2:
					let pos = stageVar(camera.boundlow)*(player(1), map(stageIntroTime)/player(1), map(bbtag_stageIntroTime));
					zoom{scale:stagevar(camera.startzoom);pos:0, $pos;lag:cond(player(1), map(stageIntroTime) = player(1), map(bbtag_stageIntroTime), 0, player(1), map(bbtag_cameraLag));stagebound:1; camerabound:0}
				case 3:
					let pos = stageVar(camera.boundhigh)*(player(1), map(stageIntroTime)/player(1), map(bbtag_stageIntroTime));
					zoom{scale:stagevar(camera.startzoom);pos:0, $pos;lag:cond(player(1), map(stageIntroTime) = player(1), map(bbtag_stageIntroTime), 0, player(1), map(bbtag_cameraLag));stagebound:1; camerabound:0}
			}
		}
		if player(1), map(stageIntroTime) > (player(1), map(bbtag_IntroDelay) * -1) && player(1), map(stageIntroBegun)
		{
			# Stage Text
			if player(1), map(bbtag_stageText) && playerno = 1
			{
				if !NumText(135790)
				{
					text{text: "Third Heights";localcoord:320,240;layerno:player(1), map(bbtag_stageTextLayerno);font:player(1), map(bbtag_stageTextFont);align:player(1), map(bbtag_stageTextAlign);pos:player(1), map(bbtag_stageTextPosX), player(1), map(bbtag_stageTextPosY);scale:player(1), map(bbtag_stageTextScaleX),player(1), map(bbtag_stageTextScaleY);id:135790;textdelay:8;removetime:player(1), map(bbtag_stageIntroTime)+player(1), map(bbtag_IntroDelay);color:player(1), map(bbtag_stageTextColorR),player(1), map(bbtag_stageTextColorG),player(1), map(bbtag_stageTextColorB),0;}
				}
				else if NumText(135790) && player(1), map(stageIntroTime) > (player(1), map(bbtag_IntroDelay) * -1)
				{
					ModifyText{id:135790;color:player(1), map(bbtag_stageTextColorR),player(1), map(bbtag_stageTextColorG),player(1), map(bbtag_stageTextColorB), cond(player(1), map(stageIntroTime) <= 0, 256-(256*((player(1), map(stageIntroTime)*-1)/player(1), map(bbtag_IntroDelay))),(256 -  (256*(player(1), map(stageIntroTime)/player(1), map(bbtag_stageIntroTime)))));}
				}
			}

			if player(1), map(stageIntroTime) < 0
			{
				#let fz = gamewidth/const240p(320/1.0);
				zoom{scale:stagevar(camera.startzoom);lag:player(1), map(bbtag_cameraLag); pos:0, 0; stagebound:1; camerabound:0}
			}
			player(1), map(stageIntroTime) := player(1), map(stageIntroTime) - 1;
		}

		if player(1), map(stageIntroTime) = (player(1), map(bbtag_IntroDelay) * -1) && !player(1), map(bbtag_stageIntroFinished) 
		{
			player(1), map(bbtag_stageIntroFinished) := 1;
		}

	}

	# DO NOT TOUCH THE NEXT LINES UNLESS YOU KNOW WHAT YOU'RE DOING.
	if map(bbtag_specialIntro) != 1 {call specialIntroCheck();}

	if player(1), map(checkSetIntro) != 1
	{
		if player(1), map(checkSetIntro) != 1{player(1), map(checkSetIntro) := 1;}
		player(1), map(bbtag_introState) := cond(player(1), map(bbtag_rollOrder) = 4,2, 1);
		player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_rollOrder) = 1,1, cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1));
	}

	if (player(1), map(bbtag_specialIntroActive) > 0 ||
	(teamSide = player(1), map(bbtag_introState) && (player(1), map(bbtag_stageIntroFinished) || !player(1), map(bbtag_stageIntro))
	&& cond((teammode = Turns || teammode = Single), 1, memberNo) = player(1), map(bbtag_teamIntroState)))
	{
		# Music Volume Ducking
		if player(1), map(bbtag_introMusicFirstRound) = 2 && player(1), map(interp_tick1) <= 60
		{
			let v = call InterpolateValue(player(1), map(starting_volume), min(max(player(1), map(starting_volume), 0), (player(1), map(starting_volume)*player(1), map(bbtag_introMusicDuckVolume))), player(1), map(interp_tick1), 60, player(1), map(bbtag_introMusicInterpolateMode));
			player(1), map(interp_tick1) := player(1), map(interp_tick1) + 1;
			ModifyBGM{volume:$v}
		}
	}

	if !(((teammode = Single && roundsexisted = roundno-1) || teammode = Simul || teammode = Tag) || roundno = 1)
	&& teamSide = player(1), map(bbtag_introState) && cond(roundno = 1,(player(1), map(bbtag_stageIntroFinished) || !player(1), map(bbtag_stageIntro)),1)
	&& cond((teammode = Turns || teammode = Single), 1, memberNo) = player(1), map(bbtag_teamIntroState)
	&& enemy, stateno = 1900000
	&& stateno = 0
	&& prevstateno = 5900
	&& map(bbtag_playerIntroFinished)
	&& map(isprevstatenointro) = 0
	{
		# for turns intros
		map(bbtag_playerIntroFinished) := 1;
		if player(1), map(bbtag_rollOrder) = 1 {player(1), map(bbtag_teamIntroState) := player(1), map(bbtag_teamIntroState) + 1;}
		else if player(1), map(bbtag_rollOrder) = 2 {player(1), map(bbtag_teamIntroState) := player(1), map(bbtag_teamIntroState) - 1;}
		else if player(1), map(bbtag_rollOrder) = 3 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 1, player(1), map(bbtag_teamIntroState) - 1, player(1), map(bbtag_teamIntroState) + 1);}
		else if player(1), map(bbtag_rollOrder) = 4 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 2, player(1), map(bbtag_teamIntroState) - 1, player(1), map(bbtag_teamIntroState) + 1);}

		if (player(1), map(bbtag_teamIntroState) > cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 1)
		|| (player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 2)
		|| ((player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 3 && player(1), map(bbtag_introState) = 1) || (player(1), map(bbtag_teamIntroState) > cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 3 && player(1), map(bbtag_introState) = 2))
		|| ((player(1), map(bbtag_teamIntroState) > cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 4 && player(1), map(bbtag_introState) = 1) || (player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 4 && player(1), map(bbtag_introState) = 2))
		{
			player(1), map(bbtag_introState) := cond(player(1), map(bbtag_rollOrder) = 4, cond(player(1), map(bbtag_introState) = 2,1,3),player(1), map(bbtag_introState) + 1);
			if player(1), map(bbtag_rollOrder) = 1 {player(1), map(bbtag_teamIntroState) := 1;}
			else if player(1), map(bbtag_rollOrder) = 2 {player(1), map(bbtag_teamIntroState) := cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1);}
			else if player(1), map(bbtag_rollOrder) = 3 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 1, cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1), 1);}
			else if player(1), map(bbtag_rollOrder) = 4 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 2, cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1), 1);}
		}
	}
	call isPreviousStateIntro();

	if player(1), map(bbtag_introState) > 0 && player(1), map(bbtag_introState) < 3 && map(bbtag_specialIntro) != 1 && player(1), map(bbtag_specialIntroActive) < 1
	&& (((teammode = Single && roundsexisted = roundno-1) || teammode = Simul || teammode = Tag) || roundno = 1)
	{

		AssertSpecial{flag: Intro;redirectid:player(1), helper(9000800), id}
		if teamSide = player(1), map(bbtag_introState) && cond(roundno = 1,(player(1), map(bbtag_stageIntroFinished) || !player(1), map(bbtag_stageIntro)),1)
		{
			if cond((teammode = Turns || teammode = Single), 1, memberNo) = player(1), map(bbtag_teamIntroState)
			{
				if !map(bbtag_playerIntroFinished) && stateno != 1900000 && (stateno = 0 || (stateno = 5900 && time > 1)) && (cond((stateno = 5900 && time > 1) || (map(isprevstatenointro) = 0 && prevstateno = 5900),1,map(isprevstatenointro) = 1) && prevstateno != 1900000) #&& (((teammode = Single && roundsexisted = roundno-1) || teammode = Simul || teammode = Tag) || roundno = 1)
				{
					ChangeState{value:1900000; continue:0} #if haven't done intro and is still in stateno = 0
				}
				# let them continue their animation and focus the camera on them
				let z = player(1), map(bbtag_cameraZoom);
				zoom{scale:$z;lag:player(1), map(bbtag_cameraLag); pos:(pos x/$z)*camerazoom, 0; stagebound:1; camerabound:0;}

				if stagetime > 8 && stateno = 0 && !map(bbtag_playerIntroFinished) && (map(isprevstatenointro) = 0 || prevstateno = 5900 || prevstateno = 1900000)
				{
					map(bbtag_playerIntroFinished) := 1;
					if player(1), map(bbtag_rollOrder) = 1 {player(1), map(bbtag_teamIntroState) := player(1), map(bbtag_teamIntroState) + 1;}
					else if player(1), map(bbtag_rollOrder) = 2 {player(1), map(bbtag_teamIntroState) := player(1), map(bbtag_teamIntroState) - 1;}
					else if player(1), map(bbtag_rollOrder) = 3 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 1, player(1), map(bbtag_teamIntroState) - 1, player(1), map(bbtag_teamIntroState) + 1);}
					else if player(1), map(bbtag_rollOrder) = 4 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 2, player(1), map(bbtag_teamIntroState) - 1, player(1), map(bbtag_teamIntroState) + 1);}

					if (player(1), map(bbtag_teamIntroState) > cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 1)
					|| (player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 2)
					|| ((player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 3 && player(1), map(bbtag_introState) = 1) || (player(1), map(bbtag_teamIntroState) > cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 3 && player(1), map(bbtag_introState) = 2))
					|| ((player(1), map(bbtag_teamIntroState) > cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 4 && player(1), map(bbtag_introState) = 1) || (player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 4 && player(1), map(bbtag_introState) = 2))
					{
						player(1), map(bbtag_introState) := cond(player(1), map(bbtag_rollOrder) = 4, cond(player(1), map(bbtag_introState) = 2,1,3),player(1), map(bbtag_introState) + 1);
						if player(1), map(bbtag_rollOrder) = 1 {player(1), map(bbtag_teamIntroState) := 1;}
						else if player(1), map(bbtag_rollOrder) = 2 {player(1), map(bbtag_teamIntroState) := cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1);}
						else if player(1), map(bbtag_rollOrder) = 3 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 1, cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1), 1);}
						else if player(1), map(bbtag_rollOrder) = 4 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 2, cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1), 1);}
					}
				}
			}
			else if map(bbtag_playerIntroFinished) != 1
			{
				ChangeState{value:1900000; continue:0}
			}
		}
		else if map(bbtag_playerIntroFinished) != 1
		{
			ChangeState{value:1900000; continue:0}
		}
	}

	if player(1), map(bbtag_introState) = 3 
	{

		# Music Volume Ducking
		if player(1), map(bbtag_introMusicFirstRound) = 2 && player(1), map(interp_tick2) <= 60
		{
			let v = call InterpolateValue(max(max(player(1), map(starting_volume), 0), (player(1), map(starting_volume)*player(1), map(bbtag_introMusicDuckVolume))), player(1), map(starting_volume), player(1), map(interp_tick2), 60, player(1), map(bbtag_introMusicInterpolateMode));
			player(1), map(interp_tick2) := player(1), map(interp_tick2) + 1;
			ModifyBGM{volume:$v}
		}

		if player(1), map(introMovementTime) = 0 && player(1), map(introMovementTimeFinished) = 0 && player(1), map(bbtag_introMovement)
		{
			player(1), map(introMovementTime) := player(1), map(bbtag_introMovementTime);
		}
		
		if player(1), map(bbtag_specialIntroActive) < 1 && player(1), map(introMovementTimeFinished) = 0 && roundstate < 2 && cond(roundno = 1,(player(1), map(bbtag_stageIntroFinished) || !player(1), map(bbtag_stageIntro)),1)
		{
			#let z = gamewidth/const240p(320/1.0);
			zoom{scale:stagevar(camera.startzoom);pos:0,0;lag:player(1), map(bbtag_cameraLag);stagebound:1;}
		}
		if player(1), map(introMovementTime) > 0 && player(1), map(bbtag_introMovement)
		{
			AssertSpecial{flag: Intro;redirectid:player(1), helper(9000800), id}
			
			if playerno = 1 {player(1), map(introMovementTime) := player(1), map(introMovementTime) - 1;}
			if playerno = 1 && gamemode = "training" {player(1), map(introMovementTime) := 0;}
			if player(1), map(introMovementTime) = 0 && player(1), map(introMovementTimeFinished) = 0 {player(1), map(introMovementTimeFinished) := 1;}
		}
	}
	else if player(1), map(bbtag_introState) = [1,2] {ctrlset{value:0}}

	if player(1), map(bbtag_specialIntroActive) > 0 && stateno != 1900000 && map(bbtag_specialIntro) != 1
	{
		ChangeState{value:1900000; continue:0}
	}

}

if roundstate = [-1, 1] && map(bbtag_specialIntro) = 1 && cond((teammode = Turns || teammode = Single), 1, memberNo) = player(1), map(bbtag_teamIntroState) && teamSide = player(1), map(bbtag_introState) && !isHelper && player(1), map(bbtag_specialIntroActive) = 0
{
	map(bbtag_playerIntroFinished) := 1;
	if player(1), map(bbtag_rollOrder) = 1 {player(1), map(bbtag_teamIntroState) := player(1), map(bbtag_teamIntroState) + 1;}
	else if player(1), map(bbtag_rollOrder) = 2 {player(1), map(bbtag_teamIntroState) := player(1), map(bbtag_teamIntroState) - 1;}
	else if player(1), map(bbtag_rollOrder) = 3 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 1, player(1), map(bbtag_teamIntroState) - 1, player(1), map(bbtag_teamIntroState) + 1);}
	else if player(1), map(bbtag_rollOrder) = 4 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 2, player(1), map(bbtag_teamIntroState) - 1, player(1), map(bbtag_teamIntroState) + 1);}

	if (player(1), map(bbtag_teamIntroState) > cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 1)
	|| (player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 2)
	|| ((player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 3 && player(1), map(bbtag_introState) = 1) || (player(1), map(bbtag_teamIntroState) > cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 3 && player(1), map(bbtag_introState) = 2))
	|| ((player(1), map(bbtag_teamIntroState) > cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1) && player(1), map(bbtag_rollOrder) = 4 && player(1), map(bbtag_introState) = 1) || (player(1), map(bbtag_teamIntroState) < 1 && player(1), map(bbtag_rollOrder) = 4 && player(1), map(bbtag_introState) = 2))
	{
		player(1), map(bbtag_introState) := cond(player(1), map(bbtag_rollOrder) = 4, cond(player(1), map(bbtag_introState) = 2,1,3),player(1), map(bbtag_introState) + 1);
		if player(1), map(bbtag_rollOrder) = 1 {player(1), map(bbtag_teamIntroState) := 1;}
		else if player(1), map(bbtag_rollOrder) = 2 {player(1), map(bbtag_teamIntroState) := cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1);}
		else if player(1), map(bbtag_rollOrder) = 3 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 1, cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1), 1);}
		else if player(1), map(bbtag_rollOrder) = 4 {player(1), map(bbtag_teamIntroState) := cond(player(1), map(bbtag_introState) = 2, cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1), 1);}
	}
}


if roundstate = [-1, 1] && map(bbtag_specialIntro) = 1 && player(1), map(bbtag_specialIntroActive) > 0 && stateno = 0
{
	player(1), map(bbtag_specialIntroActive) := player(1), map(bbtag_specialIntroActive) - 1;
}

if roundstate = [-1, 2] && player(1), map(bbtag_introState) = 3 && !isHelper && teamSide = [1,2]
{

	if player(1), map(bbtag_introMovement) && roundstate < 2
	{
		notHitBy{value: SCA} #just in case your character has damaging dashes or something
		shiftInput{input: a; output: none}
		shiftInput{input: b; output: none}
		shiftInput{input: c; output: none}
		shiftInput{input: x; output: none}
		shiftInput{input: y; output: none}
		shiftInput{input: z; output: none}
		if player(1), map(bbtag_introMovementTauntDisabled) {shiftInput{input: s; output: none}}
		if player(1), map(bbtag_introMovementTagDisabled)
		{
			shiftInput{input: d; output: none}
			shiftInput{input: w; output: none}
		}
		AssertSpecial{flag: NoIntroReset;flag2:NoStandGuard;flag3:NoCrouchGuard;flag4:NoAirGuard;flag5:NoAICheat;flag6:NoAIButtonJam}
		if ailevel {map(ailevel_) := ailevel;}
		AssertSpecial{flag: NoAiLevel}
		if map(ailevel_) {
			let x = abs(p2bodydist x);
			# get close
			if $x >= const240p(70) && map(walking_) < 2
			{
				AssertInput{flag:F;}
				map(walking) := 1;
			} # imported ai code from foobs' extended intro winpose module.
			else
			{
				if $x < const240p(70)
				{
					map(walking) := 2;
				}
				else if $x >= const240p(70) && map(walking_) = 2 && gametime % 60 = 0
				{
					map(walking) := 0;
				}
			}
		}
		if !ctrl && stateno = 0 && player(1), map(bbtag_introMovement)
		{
			ctrlSet{value: 1}
			if teamMode = Tag{map(_iksys_tagIntroFlag) := 1;}
			if TeamLeader != playerno && teamMode = Tag
			{
				if !standby {tagOut{stateno: const(StateTagLeavingScreen)}}
			}
		}
		player(1), map(bbtag_introMovementActive) := 1;
	}
	else if player(1), map(bbtag_introMovement) && roundstate = 2 && player(1), map(bbtag_introMovementActive) = 1
	{
		shiftInput{input: none; output: none}
		player(1), map(bbtag_introMovementActive) := 0;
	}
}


if roundstate = [0,1] && playerno < 3 {	
	# mutes the music during round one.
	if player(1), map(bbtag_introMusicFirstRound) = 1 && roundno = 1 {assertspecial{flag:nomusic;}}

}


ignorehitpause if roundstate = 4 && !ishelper && playerno < 3 && !player(1), map(bbtag_outroDelay) {
	# disables PotS characters' own zoom
	if authorname = "Phantom.of.the.Server" && map(cfg_winzoom) {map(cfg_winzoom):= 0;}
	
	# zoom zoom
	if ((player(1), map(bbtag_outroFocus) = 1 && (winko||wintime)) || (player(1), map(bbtag_outroFocus) = 2 && (loseko||losetime))) && player(1), map(bbtag_outroZoom) > 1 {
		let z = gamewidth/const240p(320/player(1), map(bbtag_outroZoom));
		zoom{scale:$z/camerazoom;lag:0.97; pos:(pos x/$z)*camerazoom, pos y; stagebound:1; camerabound:0;}
	}
}

}

# Outro Delay

ignorehitpause if roundstate = 3 && !ishelper && playerno <9 && teamside != 0 && player(1), map(bbtag_outroDelay) && prevstateno != 1800000 && stateno != 1800000 && alive
{
	#ChangeState{value:0; continue:0} #prevents draw game animation from playing early
}

ignorehitpause if roundstate >= 4 && !ishelper && playerno < 9 && teamSide != 0 && player(1), map(bbtag_outroDelay)
{
	# disables PotS characters' own zoom
	if authorname = "Phantom.of.the.Server" && map(cfg_winzoom) {map(cfg_winzoom):= 0;}

	# add code here
	if !player(1), map(bbtag_outroState) && !player(1), map(bbtag_teamOutroState) && playerno = TeamLeader
	{
		player(1), map(bbtag_outroState) := cond(!drawgame, cond(player(1), map(bbtag_outroRollOrder) = 1,cond(win,teamSide,enemy,teamSide), cond(lose||losetime,teamSide,enemy,teamSide)), map(bbtag_outroRollOrder));
		player(1), map(bbtag_teamOutroState) := 1;
	}

	if (player(1), map(bbtag_specialOutroActive) > 0 ||
	(teamSide = player(1), map(bbtag_outroState) && cond((teammode = Turns || teammode = Single), 1, memberNo) = player(1), map(bbtag_teamOutroState)))
	{

		# Music Volume Ducking
		if player(1), map(bbtag_outroMusicVolumeDuck) = 1 && player(1), map(interp_tick3) <= 60
		{
			let v = call InterpolateValue(player(1), map(starting_volume), min(max(player(1), map(starting_volume), 0), (player(1), map(starting_volume)*player(1), map(bbtag_introMusicDuckVolume))), player(1), map(interp_tick3), 60, player(1), map(bbtag_introMusicInterpolateMode));
			player(1), map(interp_tick3) := player(1), map(interp_tick3) + 1;
			ModifyBGM{volume:$v}
		}
	}

	if player(1), map(bbtag_outroState) > 0 && player(1), map(bbtag_outroState) < 3 && map(bbtag_specialOutro) != 1 && player(1), map(bbtag_specialOutroActive) < 1
	{
		if teamSide = player(1), map(bbtag_outroState)
		{
			if cond((teammode = Turns || teammode = Single), 1, memberNo) = player(1), map(bbtag_teamOutroState)
			{
				# let them continue their animation and focus the camera on them
				AssertSpecial{flag: roundNotOver}
				let z = player(1), map(bbtag_outroZoom);
				zoom{scale:$z;lag:player(1), map(bbtag_cameraLag); pos:(pos x/$z)*camerazoom, 0; stagebound:1; camerabound:0;}

				if ((animtime = 0 || (AnimElemTime(AnimElemNo(0)) >= player(1), map(bbtag_pauseLength))) && alive && anim != 0) || (!alive && (p2,decisiveRound || teammode = Turns || (teammode = Tag && pos x != [stageVar(playerinfo.leftbound),stageVar(playerinfo.rightbound)]))) || (stateno = cond(Const(LosePoseState),Const(LosePoseState),5500) && (animtime = 0 || (AnimElemTime(AnimElemNo(0)) >= player(1), map(bbtag_pauseLength))))
				{
					map(bbtag_playerOutroFinished) := 1;
					player(1), map(bbtag_teamOutroState) := player(1), map(bbtag_teamOutroState) + 1;

					if player(1), map(bbtag_teamOutroState) > cond(teamMode = Turns || teamMode = Single,1,NumPartner + 1)
					{
						if !drawgame
						{
							if player(1), map(bbtag_outroRollOrder) = 1
							{
								if win {player(1), map(bbtag_outroState) := enemy, teamSide;}else{player(1), map(bbtag_outroState) := 3;}
							}
							else if player(1), map(bbtag_outroRollOrder) = 2
							{
								if lose {player(1), map(bbtag_outroState) := enemy, teamSide;}else{player(1), map(bbtag_outroState) := 3;}
							}
						}
						else if drawgame
						{
							player(1), map(bbtag_outroState) := cond(player(1), map(bbtag_outroRollOrder) = 1, cond(player(1), map(bbtag_outroState) = 1, 2, 3),cond(player(1), map(bbtag_outroState) = 2, 1, 3));
						}
						player(1), map(bbtag_teamOutroState) := 1;
					}
				}
			}
			else if map(bbtag_playerOutroFinished) != 1 && map(bbtag_specialOutro) != 1
			{
				ChangeState{value:1800000; continue:0}
			}
		}
		else if map(bbtag_playerOutroFinished) != 1 && map(bbtag_specialOutro) != 1
		{
			ChangeState{value:1800000; continue:0}
		}
	}
	if player(1), map(bbtag_outroState) = 3
	{

		# Music Volume Ducking
		if player(1), map(bbtag_outroMusicVolumeDuck) = 1 && player(1), map(interp_tick4) <= 60
		{
			let v = call InterpolateValue(max(max(player(1), map(starting_volume), 0), (player(1), map(starting_volume)*player(1), map(bbtag_introMusicDuckVolume))), player(1), map(starting_volume), player(1), map(interp_tick4), 60, player(1), map(bbtag_introMusicInterpolateMode));
			player(1), map(interp_tick4) := player(1), map(interp_tick4) + 1;
			ModifyBGM{volume:$v}
		}

		if player(1), map(bbtag_specialOutroActive) < 1
		{
			#let z = 1.0;
			zoom{scale:StageVar(camera.startzoom);pos:0,0;lag:player(1), map(bbtag_cameraLag);stagebound:1;}
		}
	}
	if map(bbtag_specialOutro) = 1 && (animtime = 0 || (AnimElemVar(Time) < 0 && AnimElemTime(AnimElemNo(0)) >= 60)) && player(1), map(bbtag_specialOutroActive) > 1 && stateno != 0
	{
		map(bbtag_specialOutro) := 0;
		player(1), map(bbtag_specialOutroActive) := player(1), map(bbtag_specialOutroActive) - 1;
	}
}
if (roundstate = [0,1] || roundstate = [2,3]) && !isHelper && playerno < 9
{
	if roundstate = [2,3]
	{
		map(introstate) := 0;
	}
	if roundstate = [2,3] && !player(1), map(bbtag_introFirstRoundOnly)
	{
		#reset intro delay values
		player(1), map(checkSetIntro) := 0;
		player(1), map(bbtag_introState) := 0;
		player(1), map(bbtag_teamIntroState) := 0;
		player(1), map(bbtag_specialIntroActive) := 0;
		player(1), map(introMovementTimeFinished) := 0;
		player(1), map(bbtag_stageIntroFinished) := 1;
		if ((teammode = Single && roundsexisted = roundno-1) || teammode = Simul || teammode = Tag)
		{
			map(bbtag_playerIntroFinished) := 0;
			map(bbtag_specialIntro) := 0;
		}
		# intros still don't work during round 2 (maybe because assertspecial intro doesn't work if roundno > 1?)
		# will look into this later on.
	}
	else if roundstate = [0,1] && player(1), map(bbtag_outroDelay)
	{
		#reset outro delay values
		#call specialOutroCheck();
		player(1), map(bbtag_outroState) := 0;
		player(1), map(bbtag_teamOutroState) := 0;
		map(bbtag_playerOutroFinished) := 0;
		map(bbtag_specialOutro) := 0;
		player(1), map(bbtag_specialOutroActive) := 0;
	}
}
}
